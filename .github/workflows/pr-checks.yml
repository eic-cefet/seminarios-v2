name: PR Checks

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, edited, reopened]

concurrency:
  group: pr-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  # ============================================
  # GATE: Checklist Validation (runs first)
  # ============================================
  checklist:
    name: Checklist Validation
    runs-on: ubuntu-latest
    outputs:
      automerge: ${{ steps.parse.outputs.automerge }}
      version_bump: ${{ steps.parse.outputs.version_bump }}
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Parse and validate PR template
        id: parse
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const body = context.payload.pull_request.body || '';

            // Parse automerge (key=value format)
            const automergeMatch = body.match(/automerge=(true|false)/i);
            const automerge = automergeMatch ? automergeMatch[1].toLowerCase() : 'false';
            core.setOutput('automerge', automerge);

            // Parse version_bump (key=value format)
            const versionMatch = body.match(/version_bump=(patch|minor|major)/i);
            const versionBump = versionMatch ? versionMatch[1].toLowerCase() : '';
            core.setOutput('version_bump', versionBump);

            // Validate version_bump exists
            if (!versionBump) {
              core.setFailed('version_bump is required. Valid values: patch, minor, major');
              return;
            }

            // Validate checklist items are checked
            const requiredChecks = [
              'I have tested my code locally',
              'All tests are passing',
              'New code has adequate test coverage'
            ];

            const unchecked = requiredChecks.filter(check => {
              const pattern = new RegExp(`-\\s*\\[x\\]\\s*${check.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}`, 'i');
              return !pattern.test(body);
            });

            if (unchecked.length > 0) {
              core.setFailed(`Unchecked items:\n${unchecked.map(c => '- ' + c).join('\n')}`);
            }

  # ============================================
  # PARALLEL JOBS (depend on checklist)
  # ============================================

  tests:
    name: Tests & Coverage (95%)
    needs: checklist
    runs-on: ubuntu-latest
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: password
          MYSQL_DATABASE: testing
        ports:
          - 3306:3306
        options: --health-cmd="mysqladmin ping" --health-interval=10s --health-timeout=5s --health-retries=3
    steps:
      - uses: actions/checkout@v4

      - name: Check for backend/test changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            backend:
              - 'app/**'
              - 'bootstrap/**'
              - 'config/**'
              - 'database/**'
              - 'resources/**'
              - 'routes/**'
              - 'tests/**'
              - 'composer.json'
              - 'composer.lock'

      - name: Setup PHP
        if: steps.filter.outputs.backend == 'true'
        uses: shivammathur/setup-php@v2
        with:
          php-version: "8.4"
          extensions: dom, curl, libxml, mbstring, zip, pcntl, pdo, pdo_mysql, bcmath, intl, gd, exif, iconv
          coverage: pcov

      - name: Setup Node.js
        if: steps.filter.outputs.backend == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install pnpm
        if: steps.filter.outputs.backend == 'true'
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Get pnpm store directory
        if: steps.filter.outputs.backend == 'true'
        id: pnpm-cache
        shell: bash
        run: echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_OUTPUT

      - name: Get composer cache directory
        if: steps.filter.outputs.backend == 'true'
        id: composer-cache
        run: echo "dir=$(composer config cache-files-dir)" >> $GITHUB_OUTPUT

      - name: Cache composer dependencies
        if: steps.filter.outputs.backend == 'true'
        uses: actions/cache@v4
        with:
          path: ${{ steps.composer-cache.outputs.dir }}
          key: ${{ runner.os }}-composer-${{ hashFiles('**/composer.lock') }}
          restore-keys: ${{ runner.os }}-composer-

      - name: Cache pnpm dependencies
        if: steps.filter.outputs.backend == 'true'
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: ${{ runner.os }}-pnpm-

      - name: Install composer dependencies
        if: steps.filter.outputs.backend == 'true'
        run: composer install --no-interaction --prefer-dist --optimize-autoloader

      - name: Install pnpm dependencies
        if: steps.filter.outputs.backend == 'true'
        run: pnpm install --frozen-lockfile

      - name: Build frontend assets
        if: steps.filter.outputs.backend == 'true'
        run: pnpm run build

      - name: Copy environment file
        if: steps.filter.outputs.backend == 'true'
        run: cp .env.example .env

      - name: Generate application key
        if: steps.filter.outputs.backend == 'true'
        run: php artisan key:generate

      - name: Run tests with coverage
        if: steps.filter.outputs.backend == 'true'
        run: php artisan test --compact --min=95 --coverage-clover=coverage/backend-clover.xml
        env:
          DB_CONNECTION: mysql
          DB_HOST: 127.0.0.1
          DB_PORT: 3306
          DB_DATABASE: testing
          DB_USERNAME: root
          DB_PASSWORD: password

      - name: Upload backend coverage to Codecov
        if: steps.filter.outputs.backend == 'true'
        uses: codecov/codecov-action@v5
        with:
          files: ./coverage/backend-clover.xml
          flags: backend
          token: ${{ secrets.CODECOV_TOKEN }}

      - name: Skip message
        if: steps.filter.outputs.backend != 'true'
        run: echo "No backend/test changes detected, skipping tests"

  frontend-tests:
    name: Frontend Tests & Coverage (90%)
    needs: checklist
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check for frontend changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            frontend:
              - 'resources/js/**'
              - 'vitest.config.ts'
              - 'package.json'
              - 'pnpm-lock.yaml'
              - 'tsconfig.json'

      - name: Setup Node.js
        if: steps.filter.outputs.frontend == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install pnpm
        if: steps.filter.outputs.frontend == 'true'
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Get pnpm store directory
        if: steps.filter.outputs.frontend == 'true'
        id: pnpm-cache
        shell: bash
        run: echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_OUTPUT

      - name: Cache pnpm dependencies
        if: steps.filter.outputs.frontend == 'true'
        uses: actions/cache@v4
        with:
          path: ${{ steps.pnpm-cache.outputs.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: ${{ runner.os }}-pnpm-

      - name: Install dependencies
        if: steps.filter.outputs.frontend == 'true'
        run: pnpm install --frozen-lockfile

      - name: Run frontend tests with coverage
        if: steps.filter.outputs.frontend == 'true'
        run: pnpm test:coverage

      - name: Upload frontend coverage to Codecov
        if: steps.filter.outputs.frontend == 'true'
        uses: codecov/codecov-action@v5
        with:
          files: ./coverage/coverage-final.json
          flags: frontend
          token: ${{ secrets.CODECOV_TOKEN }}

      - name: Skip message
        if: steps.filter.outputs.frontend != 'true'
        run: echo "No frontend changes detected, skipping frontend tests"

  typecheck:
    name: TypeScript Check
    needs: checklist
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check for frontend changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            frontend:
              - 'resources/**'

      - name: Setup Node.js
        if: steps.filter.outputs.frontend == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install pnpm
        if: steps.filter.outputs.frontend == 'true'
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Install dependencies
        if: steps.filter.outputs.frontend == 'true'
        run: pnpm install --frozen-lockfile

      - name: Run typecheck
        if: steps.filter.outputs.frontend == 'true'
        run: pnpm typecheck

      - name: Skip message
        if: steps.filter.outputs.frontend != 'true'
        run: echo "No frontend changes detected, skipping typecheck"

  claude-review:
    name: Claude Code Review
    needs: checklist
    if: github.event.pull_request.head.repo.full_name == github.repository
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get PR diff, review and categorize with Claude
        id: claude
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          CLAUDE_MODEL: ${{ vars.CLAUDE_MODEL || 'claude-sonnet-4-20250514' }}
        run: |
          git fetch origin ${{ github.base_ref }}
          git diff origin/${{ github.base_ref }}...HEAD > /tmp/diff.txt
          git diff origin/${{ github.base_ref }}...HEAD --name-only > /tmp/files.txt
          git diff origin/${{ github.base_ref }}...HEAD --stat > /tmp/stats.txt

          # Truncate diff if too large
          head -c 100000 /tmp/diff.txt > /tmp/diff_truncated.txt

          # Build combined prompt for review and categorization
          cat > /tmp/prompt.txt << 'PROMPT'
          You are reviewing a pull request. Do two things:

          1. **Code Review**: Provide constructive feedback on:
             - Potential bugs or issues
             - Code quality and best practices
             - Security concerns
             - Performance considerations
             Be concise and actionable.

          2. **Categorization**: You MUST categorize this PR with AT LEAST ONE label from:
             - "feature" (new functionality)
             - "bugfix" (bug fixes)
             - "documentation" (docs, README, comments)
             - "tests" (test files)
             - "frontend" (resources/js, CSS, views)
             - "backend" (PHP, routes, controllers, models)
             - "config" (configuration files, env, CI/CD)
             - "refactor" (code restructuring without new features)
             - "dependencies" (package updates)

             Always pick at least one label. Multiple labels are encouraged if applicable.

          **Response format** (MUST follow exactly):
          ```review
          [Your code review in markdown here]
          ```

          ```labels
          ["label1", "label2"]
          ```

          Changed files:
          PROMPT

          cat /tmp/files.txt >> /tmp/prompt.txt
          echo -e "\n\nChange statistics:" >> /tmp/prompt.txt
          cat /tmp/stats.txt >> /tmp/prompt.txt
          echo -e "\n\nDiff:\n\`\`\`" >> /tmp/prompt.txt
          cat /tmp/diff_truncated.txt >> /tmp/prompt.txt
          echo -e "\n\`\`\`" >> /tmp/prompt.txt

          jq -n --rawfile prompt /tmp/prompt.txt \
            --arg model "$CLAUDE_MODEL" \
            '{
              model: $model,
              max_tokens: 4096,
              messages: [{
                role: "user",
                content: $prompt
              }]
            }' > /tmp/payload.json

          # Call Claude API
          curl -s https://api.anthropic.com/v1/messages \
            -H "Content-Type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -d @/tmp/payload.json > /tmp/response.json

          # Extract full response
          RESPONSE=$(jq -r '.content[0].text // .error.message // "Failed to get response"' /tmp/response.json)

          # Extract review (between ```review and ```)
          REVIEW=$(echo "$RESPONSE" | sed -n '/```review/,/```/p' | sed '1d;$d')
          if [ -z "$REVIEW" ]; then
            REVIEW="$RESPONSE"
          fi

          # Extract labels (between ```labels and ```)
          LABELS=$(echo "$RESPONSE" | sed -n '/```labels/,/```/p' | sed '1d;$d' | tr -d '\n')
          if ! echo "$LABELS" | jq -e 'type == "array"' > /dev/null 2>&1; then
            LABELS="[]"
          fi

          echo "Extracted labels: $LABELS"

          # Save outputs
          echo "review<<ENDOFREVIEW" >> $GITHUB_OUTPUT
          echo "$REVIEW" >> $GITHUB_OUTPUT
          echo "ENDOFREVIEW" >> $GITHUB_OUTPUT

          echo "labels=$LABELS" >> $GITHUB_OUTPUT

      - name: Generate GitHub App Token for this job
        id: app-token-review
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Post review comment and apply labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token-review.outputs.token }}
          script: |
            // Post review comment
            const review = process.env.REVIEW_CONTENT;
            const body = `## Claude Code Review\n\n${review}`;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('Claude Code Review')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

            // Sync category labels: remove stale ones, add new ones
            const labelsJson = process.env.LABELS || '[]';
            let newLabels = [];
            try {
              newLabels = JSON.parse(labelsJson);
            } catch (e) {
              console.log('Failed to parse labels:', e);
              return;
            }

            const validLabels = ['feature', 'bugfix', 'documentation', 'tests', 'frontend', 'backend', 'config', 'refactor', 'dependencies'];
            const labelColors = {
              'feature': '0e8a16',
              'bugfix': 'd73a4a',
              'documentation': '0075ca',
              'tests': 'fbca04',
              'frontend': '1d76db',
              'backend': '5319e7',
              'config': 'c5def5',
              'refactor': 'fef2c0',
              'dependencies': '006b75'
            };

            const filteredNew = newLabels.filter(l => validLabels.includes(l));
            if (filteredNew.length === 0) {
              console.log('No valid labels from Claude, skipping label sync');
              return;
            }

            // Ensure all new labels exist in the repo
            for (const label of filteredNew) {
              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label
                });
              } catch (e) {
                if (e.status === 404) {
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: label,
                    color: labelColors[label] || 'ededed'
                  });
                }
              }
            }

            // Get current category labels on the PR
            const { data: currentLabelsData } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            const currentCategoryLabels = currentLabelsData
              .map(l => l.name)
              .filter(l => validLabels.includes(l));

            // Remove labels no longer in the new set
            const labelsToRemove = currentCategoryLabels.filter(l => !filteredNew.includes(l));
            for (const label of labelsToRemove) {
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  name: label
                });
              } catch (e) {
                console.log('Failed to remove label:', label, e.message);
              }
            }

            // Add labels not already present
            const labelsToAdd = filteredNew.filter(l => !currentCategoryLabels.includes(l));
            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: labelsToAdd
              });
            }

            console.log('Label sync complete. Removed:', labelsToRemove, 'Added:', labelsToAdd);
        env:
          REVIEW_CONTENT: ${{ steps.claude.outputs.review }}
          LABELS: ${{ steps.claude.outputs.labels }}

  # ============================================
  # FINAL GATE (always runs, checks all jobs)
  # ============================================

  final-status:
    name: Final Status
    needs: [checklist, tests, frontend-tests, typecheck, claude-review]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Check job results
        run: |
          echo "Checklist: ${{ needs.checklist.result }}"
          echo "Tests: ${{ needs.tests.result }}"
          echo "Frontend Tests: ${{ needs.frontend-tests.result }}"
          echo "Typecheck: ${{ needs.typecheck.result }}"
          echo "Claude Review: ${{ needs.claude-review.result }}"

          # Fail if any required job failed
          if [[ "${{ needs.checklist.result }}" == "failure" ]]; then
            echo "::error::Checklist validation failed"
            exit 1
          fi
          if [[ "${{ needs.tests.result }}" == "failure" ]]; then
            echo "::error::Tests failed"
            exit 1
          fi
          if [[ "${{ needs.frontend-tests.result }}" == "failure" ]]; then
            echo "::error::Frontend tests failed"
            exit 1
          fi
          if [[ "${{ needs.typecheck.result }}" == "failure" ]]; then
            echo "::error::TypeScript check failed"
            exit 1
          fi
          if [[ "${{ needs.claude-review.result }}" == "failure" ]]; then
            echo "::error::Claude review failed"
            exit 1
          fi

          echo "All checks passed or were appropriately skipped"

      - name: Checkout code
        if: needs.checklist.outputs.automerge == 'true'
        uses: actions/checkout@v4

      - name: Generate GitHub App Token for automerge
        if: needs.checklist.outputs.automerge == 'true'
        id: app-token-automerge
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Add automerge label and enable automerge
        if: needs.checklist.outputs.automerge == 'true'
        env:
          GH_TOKEN: ${{ steps.app-token-automerge.outputs.token }}
        run: |
          gh pr edit ${{ github.event.pull_request.number }} --add-label "automerge"
          gh pr merge ${{ github.event.pull_request.number }} --auto --squash
